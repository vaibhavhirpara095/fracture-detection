# -*- coding: utf-8 -*-
"""Fracture Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mX7KYblYT9nrpDjPSYrPDayBqqR9n69F

**Mount For Google Drive**
"""

from google.colab import drive
drive.mount('/content/drive')

"""**Import Require Library**"""

import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D, Dropout
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import confusion_matrix, classification_report
from tensorflow.keras.preprocessing import image

train_dir = "/content/drive/MyDrive/X-ray/train"
val_dir = "/content/drive/MyDrive/X-ray/val"

img_size = 224
batch_size = 32

train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    zoom_range=0.2,
    horizontal_flip=True
)

val_datagen = ImageDataGenerator(rescale=1./255)

train_data = train_datagen.flow_from_directory(
    train_dir,
    target_size=(img_size, img_size),
    batch_size=batch_size,
    class_mode='binary'
)

val_data = val_datagen.flow_from_directory(
    val_dir,
    target_size=(img_size, img_size),
    batch_size=batch_size,
    class_mode='binary',
    shuffle=False
)

base_model = MobileNetV2(weights="imagenet", include_top=False, input_shape=(img_size, img_size, 3))
base_model.trainable = False  # Freeze base model

x = GlobalAveragePooling2D()(base_model.output)
x = Dropout(0.3)(x)
x = Dense(128, activation="relu")(x)
x = Dropout(0.3)(x)
output = Dense(1, activation="sigmoid")(x)

model = Model(inputs=base_model.input, outputs=output)

model.compile(optimizer=Adam(learning_rate=0.0001),
              loss="binary_crossentropy",
              metrics=["accuracy"])

history = model.fit(
    train_data,
    validation_data=val_data,
    epochs=2  # You can increase later
)

plt.figure(figsize=(12,5))

# Accuracy
plt.subplot(1,2,1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.title("Accuracy")
plt.legend()

# Loss
plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.title("Loss")
plt.legend()

plt.show()

y_true = val_data.classes
y_pred = (model.predict(val_data) > 0.5).astype("int32")

cm = confusion_matrix(y_true, y_pred)

plt.figure(figsize=(6,6))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=['Not Fractured','Fractured'], yticklabels=['Not Fractured','Fractured'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

print("Classification Report:\n")
print(classification_report(y_true, y_pred, target_names=['Not Fractured','Fractured']))

from tensorflow.keras.preprocessing import image

def predict_single_image(img_path, model, img_size=224):
    # Load the image
    img = image.load_img(img_path, target_size=(img_size, img_size))
    # Convert to array
    img_array = image.img_to_array(img)
    # Expand dims to match (1, 224, 224, 3)
    img_array = np.expand_dims(img_array, axis=0)
    # Normalize like training
    img_array = img_array / 255.0

    # Predict
    prediction = model.predict(img_array)[0][0]

    if prediction > 0.5:
        print(f"Prediction: Fractured ({prediction:.2f})")
    else:
        print(f"Prediction: Not Fractured ({1 - prediction:.2f})")


    plt.imshow(img)
    plt.axis("off")
    plt.title("Predicted: Fractured" if prediction > 0.5 else "Predicted: Not Fractured")
    plt.show()


img_path = "/content/drive/MyDrive/X-ray/train/fractured/10-rotated1-rotated2-rotated2.jpg"  # Replace with your own image path
predict_single_image(img_path, model, img_size)